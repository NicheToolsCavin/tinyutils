<p>
  Manual link checking works for occasional audits, but modern web development demands automation. When you're deploying multiple times per day, managing a portfolio of client sites, or maintaining a content-heavy platform, you need programmatic broken link detection. An API-based approach integrates link checking directly into your development workflow—catching broken links before they reach production, alerting you when external resources disappear, and maintaining link health without manual intervention.
</p>

<h2 id="tldr">TL;DR</h2>
<ul>
  <li>TinyUtils <a href="/tools/dead-link-finder/">Dead Link Finder</a> provides a JSON API for automation</li>
  <li>Integrate into CI/CD pipelines to fail builds on broken links</li>
  <li>Set up scheduled monitoring for production sites</li>
  <li>Parse structured JSON responses for automated remediation</li>
  <li>No API key required for reasonable usage</li>
</ul>

<h2 id="why-api"><span id="why"></span>Why Use an API for Link Checking?</h2>

<h3>Automation Over Manual Clicks</h3>
<p>
  Browser-based tools require human interaction—someone has to click, wait, review, and export. API-based checking runs unattended. Set it up once, and it works while you sleep. This isn't about convenience; it's about catching problems before users report them.
</p>

<h3>CI/CD Integration</h3>
<p>
  Modern deployment pipelines run automated tests before releasing code. Link checking belongs in that pipeline. A broken link introduced in a content update should block deployment just like a failed unit test. The API enables this integration—your GitHub Action, GitLab CI, or Jenkins job calls the endpoint and acts on the results.
</p>

<h3>Continuous Monitoring</h3>
<p>
  External links break without warning. The resource you linked to last month might be gone today. Scheduled API calls—daily, weekly, or hourly depending on your needs—catch these changes. Alert integrations (Slack, email, PagerDuty) notify your team immediately when links fail.
</p>

<h3>Programmatic Remediation</h3>
<p>
  API responses are structured data, not visual reports. Parse the JSON, identify 404s, cross-reference with your CMS, and trigger automated fixes. Some teams automatically replace broken links with archived versions from the Wayback Machine. Others open tickets in their issue tracker. The API enables whatever workflow fits your needs.
</p>

<h2 id="endpoint"><span id="api"></span>The Dead Link Finder API</h2>
<p>
  The TinyUtils Dead Link Finder exposes a JSON API that mirrors the web interface's functionality. Everything you can do through the browser, you can do programmatically.
</p>

<h3>Request Format</h3>
<pre><code>POST /api/check
Content-Type: application/json

{
  "pageUrl": "https://example.com/page-to-check",
  "scope": "domain",
  "includeAssets": false,
  "httpFallback": false,
  "robots": "respect"
}</code></pre>

<h3>Parameters</h3>
<table>
  <thead>
    <tr>
      <th>Parameter</th>
      <th>Type</th>
      <th>Description</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>pageUrl</td>
      <td>string (required)</td>
      <td>The URL to crawl and check links from</td>
    </tr>
    <tr>
      <td>scope</td>
      <td>string</td>
      <td>"domain" (same domain), "same-origin" (same origin), or "all" (external too)</td>
    </tr>
    <tr>
      <td>includeAssets</td>
      <td>boolean</td>
      <td>Check images, scripts, and stylesheets in addition to links</td>
    </tr>
    <tr>
      <td>httpFallback</td>
      <td>boolean</td>
      <td>Try HTTP if HTTPS fails (not recommended for HSTS sites)</td>
    </tr>
    <tr>
      <td>robots</td>
      <td>string</td>
      <td>"respect" (honor robots.txt) or "ignore"</td>
    </tr>
  </tbody>
</table>

<h3>Response Format</h3>
<pre><code>{
  "ok": true,
  "rows": [
    {
      "link": "https://example.com/missing-page",
      "status": 404,
      "statusText": "Not Found",
      "finalUrl": null,
      "redirectChain": [],
      "error": null
    },
    {
      "link": "https://example.com/moved-page",
      "status": 301,
      "statusText": "Moved Permanently",
      "finalUrl": "https://example.com/new-location",
      "redirectChain": ["https://example.com/moved-page"],
      "error": null
    }
  ],
  "meta": {
    "runTimestamp": "2024-01-15T10:30:00Z",
    "mode": "domain",
    "totals": {
      "checked": 47,
      "ok": 42,
      "broken": 3,
      "redirects": 2
    },
    "requestId": "abc-123-def"
  }
}</code></pre>

<h3>Error Response</h3>
<pre><code>{
  "ok": false,
  "message": "Invalid URL format",
  "code": "INVALID_URL",
  "requestId": "abc-123-def"
}</code></pre>

<h2 id="integration">Integration Patterns</h2>

<h3>GitHub Actions</h3>
<p>
  Add link checking to your GitHub workflow. This example runs on every push to main and fails if broken links are found:
</p>
<pre><code>name: Link Check
on:
  push:
    branches: [main]
  schedule:
    - cron: '0 6 * * *'  # Daily at 6am UTC

jobs:
  check-links:
    runs-on: ubuntu-latest
    steps:
      - name: Check for broken links
        run: |
          RESPONSE=$(curl -s -X POST https://tinyutils.com/api/check \
            -H "Content-Type: application/json" \
            -d '{"pageUrl":"https://your-site.com","scope":"domain"}')

          BROKEN=$(echo $RESPONSE | jq '.meta.totals.broken')
          if [ "$BROKEN" -gt 0 ]; then
            echo "Found $BROKEN broken links!"
            echo $RESPONSE | jq '.rows[] | select(.status >= 400)'
            exit 1
          fi</code></pre>

<h3>Node.js Script</h3>
<p>
  For more complex logic, use a Node.js script that can process results and take actions:
</p>
<pre><code>const checkLinks = async (siteUrl) => {
  const response = await fetch('https://tinyutils.com/api/check', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({
      pageUrl: siteUrl,
      scope: 'all',
      includeAssets: true
    })
  });

  const data = await response.json();

  if (!data.ok) {
    throw new Error(data.message);
  }

  const broken = data.rows.filter(r => r.status >= 400);
  const redirects = data.rows.filter(r => r.status >= 300 && r.status < 400);

  return { broken, redirects, meta: data.meta };
};</code></pre>

<h3>Python Integration</h3>
<pre><code>import requests
import json

def check_site_links(url, scope="domain"):
    response = requests.post(
        "https://tinyutils.com/api/check",
        json={"pageUrl": url, "scope": scope}
    )
    data = response.json()

    if not data["ok"]:
        raise Exception(data["message"])

    broken = [r for r in data["rows"] if r["status"] >= 400]
    return broken, data["meta"]["totals"]</code></pre>

<h3>Scheduled Monitoring with Cron</h3>
<p>
  Set up a cron job to check your site regularly and send alerts:
</p>
<pre><code># Run daily at midnight
0 0 * * * /path/to/link-check.sh | mail -s "Link Check Report" team@company.com</code></pre>

<h2 id="status-codes">Understanding Status Codes</h2>
<table>
  <thead>
    <tr>
      <th>Code Range</th>
      <th>Meaning</th>
      <th>Action</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>200-299</td>
      <td>Success</td>
      <td>Link is working</td>
    </tr>
    <tr>
      <td>301, 308</td>
      <td>Permanent redirect</td>
      <td>Update to final URL</td>
    </tr>
    <tr>
      <td>302, 307</td>
      <td>Temporary redirect</td>
      <td>Monitor but keep original</td>
    </tr>
    <tr>
      <td>400</td>
      <td>Bad request</td>
      <td>Check URL format</td>
    </tr>
    <tr>
      <td>401, 403</td>
      <td>Authorization required</td>
      <td>Link may require login</td>
    </tr>
    <tr>
      <td>404</td>
      <td>Not found</td>
      <td>Resource is gone—fix or remove</td>
    </tr>
    <tr>
      <td>500-599</td>
      <td>Server error</td>
      <td>Temporary—recheck later</td>
    </tr>
    <tr>
      <td>0 or null</td>
      <td>Connection failed</td>
      <td>DNS failure or timeout</td>
    </tr>
  </tbody>
</table>

<h2 id="use-cases">Common Use Cases</h2>

<h3>Pre-Deploy Validation</h3>
<p>
  Check staging environments before promoting to production. Catch content editor mistakes, broken CMS migrations, and misconfigured redirects before users see them.
</p>

<h3>Content Migration Audits</h3>
<p>
  Moving to a new CMS or redesigning your site? Run link checks before and after to ensure no links were broken in the transition. Compare results to identify regressions.
</p>

<h3>SEO Monitoring</h3>
<p>
  Broken outbound links can hurt your search rankings. Monitor external links regularly—especially to high-value resources you cite frequently. When external sites restructure, you'll know immediately.
</p>

<h3>Client Site Management</h3>
<p>
  Agencies managing multiple client sites need automated monitoring. Set up scheduled checks for each client, aggregate results into dashboards, and demonstrate proactive maintenance in client reports.
</p>

<h3>Documentation Freshness</h3>
<p>
  Technical documentation links to APIs, libraries, and external resources that change frequently. Regular link checks ensure your docs stay accurate and useful.
</p>

<h2 id="best-practices">Best Practices</h2>

<h3>Rate Limiting</h3>
<p>
  The API includes built-in concurrency limits to respect target sites. For checking multiple pages, stagger your requests rather than firing them all simultaneously. A 1-2 second delay between calls is courteous.
</p>

<h3>Error Handling</h3>
<p>
  Always check the <code>ok</code> field before processing results. Handle timeouts gracefully—some servers respond slowly. Implement retry logic with exponential backoff for 5xx errors.
</p>

<h3>Result Caching</h3>
<p>
  Don't check the same URLs repeatedly in short periods. Cache results for at least a few hours. This reduces load on both the API and the target sites you're checking.
</p>

<h3>Scope Selection</h3>
<p>
  Start with "domain" scope for internal link validation. Use "all" scope when you need to verify external links too—but be aware this takes longer and includes links you can't fix directly.
</p>

<h2 id="faq">Frequently Asked Questions</h2>

<h3>Are there rate limits?</h3>
<p>
  The API has built-in concurrency limits to be respectful to target sites. For high-volume needs, batch your requests and add delays between calls. Excessive usage may be throttled.
</p>

<h3>Can I check multiple pages in one request?</h3>
<p>
  Each API call checks links from a single page. For site-wide audits, call the API for each page you want to check. Parallelize within reason, but respect rate limits.
</p>

<h3>What about authenticated pages?</h3>
<p>
  The API checks publicly accessible pages. Content behind login, paywalls, or IP restrictions won't be accessible. For authenticated content, you'll need custom tooling that can handle your authentication mechanism.
</p>

<h3>How long do requests take?</h3>
<p>
  Response time depends on the number of links and the speed of the target servers. A typical page with 50 links might take 5-15 seconds. Pages with many external links to slow servers take longer.
</p>

<h3>What's the difference from the web tool?</h3>
<p>
  Same functionality, different interface. The web tool is for one-off manual checks. The API is for automation. Same backend, same accuracy, different access method.
</p>

<h3>Can I use this for competitive analysis?</h3>
<p>
  You can check any publicly accessible URL. However, respect robots.txt and don't hammer competitor sites with excessive requests.
</p>

<h2 id="why-online">Why Use an Online API?</h2>
<ul>
  <li><strong>No infrastructure:</strong> No servers to maintain, no binaries to update</li>
  <li><strong>Consistent behavior:</strong> Same results from any client or platform</li>
  <li><strong>External perspective:</strong> Checks from outside your network, like real users</li>
  <li><strong>Always current:</strong> Latest detection logic without client updates</li>
  <li><strong>Simple integration:</strong> Standard REST API works with any language</li>
</ul>

<h2 id="next">Ready to Automate?</h2>
<p>
  Start with the interactive <a href="/tools/dead-link-finder/">Dead Link Finder</a> to understand the output format, then integrate the API into your workflow. Catch broken links automatically, fail builds on errors, and maintain link health without manual effort.
</p>
<p>
  For agency-scale monitoring, see our <a href="/blog/broken-link-checker-agencies">agency broken link workflow</a>. For recovering already-broken links, check out <a href="/blog/fix-broken-links-archive-org">fixing broken links with Archive.org</a>.
</p>
